# 미로찾기

- 최단거리를 구해야할 때는 BFS를 쓸 수 있다.

# 특정 거리의 도시 찾기

- 모든 간선의 비용이 동일할 때는 너비 우선 탐색을 이용하여 최단 거리를 찾을 수 있다.

# 연구소

- 언제 전역변수로 선언해야하는 건지 헷갈림..
- 배열은 전역변수로 선언하지 않아도 수정이 가능핟듯..!?

[Python 지역변수, 전역변수 관련 개념](https://medium.com/@dltkddud4403/python-%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98-%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98-%EA%B4%80%EB%A0%A8-%EA%B0%9C%EB%85%90-4ea2a1865071)

# 경쟁적 전염

- 어차피 처음에 작은 바이러스부터 넣어놓으면 그 이후에는 큐에 순서대로 들어갈 것이기 때문에 처음에만 한번 정렬을 해주면 된다.
- 굳이 heapq를 사용할 필요가 없었음.

# 괄호변환

- 굳이 count 변수를 2개 쓸 필요가 없다.

# 연산자 끼워넣기

- max_value 초기화 시, 음수가 나오는 경우도 생각해야한다.
- 나눗셈 연산자를 할 때는 음수를 양수로 나누는 경우도 생각하자
- 연산자를 따
- 순열, 조합은 dfs, bfs로 풀 수 있다. 이 방법 숙지해두기!!!!!!!

    → 다시 풀어보기, 속도의 관점에서 생각해보기, int(now /data[i]) now//data[i] 차이점 ?

    - / 와  //의 차이

        x / y : x와 y의 몫

        int(x/y) : x와 y의 몫을 반올림하여 정수로 만든 것

        음수를 양수로 나눌 때는 양수로 바꾼 뒤 몫을 취하고 그 몫을 음수로 바꾼 것과 같다.

        x // y : x와 y의 정수로 내림한 몫

        정수 나눗셈이라고 도합니다. 결괏값의 형이 꼭 int 일 필요는 없지만, 결괏값은 항상 정수입니다. **결과는 항상 음의 무한대를 향해 내림** 됩니다: 1//2 는 0, (-1)//2 는 -1, 1//(-2) 는 -1, (-1)//(-2) 는 0 입니다.

        ex ) 

        -1 / 4 = -0.25

        int (-1 / 4) = 0

        -1 // 4 =  -1

    - 속도의 관점

        bfs, dfs 는 노드의 수가 N일 때 O(N)의 시간복잡도를 가진다. 

        내가 풀었던 순열 방식은 순열을 만드는데 걸리는 시간 * 순열을 순회하는데 걸리는 시간(N!) * N번 계산

# 감시 피하기
